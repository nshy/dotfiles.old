#!/bin/bash

INSTALL_PATH="/mingw-cache/packages"
MINGW_PATH="/usr/i686-pc-mingw32/sys-root/mingw"
MINGW_PATH2="usr/i686-pc-mingw32/sys-root/mingw"
MINGW_BASE=~/bin/cygwin/pk-mingw-list

MIRROR_PORTS="ftp://ftp.cygwinports.org/pub/cygwinports"
MIRROR_MAIN="http://linux.rz.ruhr-uni-bochum.de/download/cygwin"
MAIN_LIST=/mingw-cache/main.list
PORTS_LIST=/mingw-cache/ports.list

declare -A url_to_file
url_to_file["$MIRROR_MAIN"]="$MAIN_LIST"
url_to_file["$MIRROR_PORTS"]="$PORTS_LIST"

PK_TMP_FILES=`mktemp`

shopt -s nullglob
trap pk-on-exit EXIT
set -e

pk-make-tmp()
{
  declare f=`mktemp`
  echo "$f" >> "$PK_TMP_FILES"
  echo "$f"
}

pk-on-exit()
{
  rm -f `cat "$PK_TMP_FILES"`
  rm "$PK_TMP_FILES"
}

# pk-mirror-dir()
# {
#   echo "$1" | sed -e "s/:/%3a/g" -e "s:/:%2f:g"
# }

pk-create-local-dirs()
{
    [ -d libs ] || mkdir libs
    [ -d packages ] || mkdir packages
    [ -d scripts ] || mkdir scripts
    [ -f installed.list ] || touch installed.list
}

pk-find-desc()
{
  declare pkg="$1"
  set +e
  # find package description
  declare mirror
  for mirror in "$MIRROR_MAIN" "$MIRROR_PORTS"
  do
    tmp_script=`pk-make-tmp`
    cat >"$tmp_script" - <<'CODE'
      BEGIN {
        RS = "\n\n@ "
        FS = "\n"
      }
      {
        if ($1 == package) {
          desc = $0
          px++
        }
      }
      END {
        if (px == 1 && desc != "")
          print desc
        else
          exit 1
      }
CODE
  awk -v package="$pkg" -f "$tmp_script" ${url_to_file["$mirror"]} && {
    set -e
    pk_find_desc_mirror="$mirror"
    return
  }
  done
  set -e
  echo "ERROR: $pkg not found in mirrors" >&2
  exit 1
}

pk-setup-status()
{
  [ -d "$INSTALL_PATH/$1" ]
}

pk-install-status()
{
  [ -d "$pk_install_dir/packages/$1" ]
}

pk-false-status()
{
  return 1
}

pk-setup-package()
{
  declare pkg="$1"
  declare tmp_desc=`pk-make-tmp`
  declare tmp_deps=`pk-make-tmp`
  declare tmp_file=`pk-make-tmp`

  # find package description
  pk-find-desc "$pkg" > "$tmp_desc"
  declare ver2=`awk '/^version: / { print $2; exit }' "$tmp_desc"`
  declare file2="$pkg/$pkg-$ver2.tar.bz2"
  declare desc2="$pkg/desc"
  declare path2=`awk '/^install: / { print $2; exit }' "$tmp_desc"`

  [ -d "$pkg" ] || mkdir "$pkg"
  # download new version
  # cp "../mirror/$file2" "$tmp_file"
  curl -# "$pk_find_desc_mirror/$path2" >"$tmp_file"
  cp "$tmp_desc" "$desc2"
  cp "$tmp_file" "$file2"

  # check the md5
  declare dig1=`cat "$tmp_desc" | awk '/^install: / { print $4; exit }'`
  declare dig2=`md5sum $file2 | awk '{print $1}'`
  [ "$dig1" != "$dig2" ] && {
    echo "ERROR: md5 sum did not match"
    rm "$file2"
    rm "$desc2"
    exit 1
  }

  return 0
}

pk-print-deps()
{
  declare deps=`grep 'requires' -`
  declare deps=${deps#requires:}
  echo "$deps"
}

pk-print-ver()
{
  awk '/^version: / { print $2; exit }' -
}

pk-make-dep-list2()
{
  declare pkg="$1"
  declare find_fun="$2"
  declare check_fun="$3"

  declare tmp_deps=`pk-make-tmp`

  cd "$INSTALL_PATH"
  add_deps()
  {
    declare dep
    for dep in `"$find_fun" "$1" | pk-print-deps`
    do
      # echo "$dep" >&2
      grep "$dep" "$MINGW_BASE" >&/dev/null && continue
      add_deps "$dep"
    done

    "$check_fun" "$1" && return
    echo "$1" >> "$tmp_deps"
  }
  add_deps "$pkg"

  # find uniq lines without messing with sort
  awk '!seen[$0]++' "$tmp_deps"
}

pk-check-package()
{
  declare pkg="$1"
  declare tab="$2"

  declare file="$INSTALL_PATH/$pkg/vers"
  declare tab2="$tab  "

  declare tmp_diff=`pk-make-tmp`

  declare pkg v1
  cat "$file" | while read pkg v1
  do
    if [[ "$pkg" =~ ^my- ]]
    then
      pk-check-package "$pkg" "$tab2" >> "$tmp_diff"
    else
      declare v2=`cat "$INSTALL_PATH/$pkg/desc" | pk-print-ver`
      [ "$v2" == "$v1" ] && continue
      echo "$tab2$pkg $v1 -> $v2" >> "$tmp_diff"
    fi
  done
  [ -s "$tmp_diff" ] && {
    echo "$tab$pkg is out-of-date, diff:"
    cat "$tmp_diff"
    return 1
  }
  return 0
}

pk-check-sync()
{
  declare name="$1"
  declare dir="$2"
  declare tab="$3"

  declare tab2="$tab  "
  declare tmp_diff=`pk-make-tmp`


  for dep in `cat "$INSTALL_PATH/$name/desc" | pk-print-deps`
  do
    [ ! -d "$dir/packages/$dep" ] && continue
    declare v1=`cat "$INSTALL_PATH/$dep/desc" | pk-print-ver`
    declare v2=`cat "$dir/packages/$dep/desc" | pk-print-ver`
    [ "$v1" == "$v2" ] && continue
    echo "$tab2$dep cache: $v1, local: $v2" >> "$tmp_diff"
  done
  [ -s "$tmp_diff" ] && {
    echo "$tab$name is out-of-sync, diff:"
    cat "$tmp_diff"
    return 1
  }
  return 0
}

pk-local-desc()
{
  cat "$dir/packages/$1/desc"
}

pk-cache-desc()
{
  cat "$INSTALL_PATH/$1/desc"
}

pk-pkg-to-tar()
{
  declare ver=`pk-cache-desc "$name" | pk-print-ver`
  echo "$1-$ver.tar.bz2"
}

pk-print-tar-files()
{
  declare name="$1"
  declare pack_dir="$2"

  declare file=`pk-tar-file "$name" "$pack_dir"`

  declare tmp_names=`pk-make-tmp`
  declare tmp_types=`pk-make-tmp`
  set +e
  tar tj --transform="s,$MINGW_PATH2,.," --show-transformed-names -f "$file" \
    --wildcards "$MINGW_PATH2/*" 2>/dev/null >"$tmp_names"
  tar tvj -f "$file" --wildcards "$MINGW_PATH2/*" 2>/dev/null >"$tmp_types"
  paste -d $'\n' "$tmp_types" "$tmp_names" | awk 'NR % 2 == 1 { d = $1 ~ /^d/ } (NR % 2 == 0) && !d { print $0 }'
  set -e
}

pk-check-clash2()
{
  declare name="$1"
  declare dir="$2"
  declare pack_dir="$3"

  declare tmp_clash=`pk-make-tmp`
  declare tmp_files=`pk-make-tmp`
  declare tmp_files2=`pk-make-tmp`
  declare res=0

  pk-print-tar-files "$name" "$INSTALL_PATH" > "$tmp_files"

  pushd "$dir/packages" >/dev/null
  for name2 in *
  do
    pk-print-tar-files "$name2" "$pack_dir" > "$tmp_files2"
    # set intersection
    comm -12 <(sort "$tmp_files") <(sort "$tmp_files2") > "$tmp_clash"
    [ -s "$tmp_clash" ] && {
      echo "ERROR: package $name clash with $name2"
      echo "       clashed files are:"
      cat "$tmp_clash"
      res=1
      break
    }
  done
  popd >/dev/null
  return $res
}

pk-tar-file()
{
  declare name="$1"
  declare dir="$2"
  declare ver=`cat "$dir/$name/desc" | pk-print-ver`
  echo "$dir/$name/$name-$ver.tar.bz2"
}

pk-extract2()
{
  declare name="$1"
  declare dir="$2"
  declare pack_dir="$3"

  declare file=`pk-tar-file "$name" "$pack_dir"`
  declare build_dir="$dir/libs"

  pushd "$build_dir" >/dev/null

  # extract package removing mingw prefix of filenames
  tar xj --transform="s,$MINGW_PATH2,.," --show-transformed-names -f "$file" \
    --wildcards "$MINGW_PATH2/*" 2>/dev/null || echo >/dev/null # nop

  #fix .la and .pc files
  declare file
  grep -l "$MINGW_PATH" lib/pkgconfig/*.pc /lib/*.la | while read file
  do
    sed -i -re "s,$MINGW_PATH,$build_dir,g" $file
  done

  popd >/dev/null
}

pk-create-vers()
{
  declare name="$1"

  declare dep
  for dep in `cat "$INSTALL_PATH/$1/desc" | pk-print-deps`
  do
    declare v=`cat "$INSTALL_PATH/$dep/desc" | pk-print-ver`
    echo "$dep" "$v"
  done
}

pk-rm-package()
{
  declare name="$1"
  declare dir="$2"
  declare tmp_list=`pk-make-tmp`

  pk-print-tar-files "$name" "$dir/packages" > "$tmp_list"

  pushd "$dir/libs" >/dev/null

  declare ifs_save="$IFS"
  IFS=$'\n'
  [ -s "$tmp_list" ] && rm `cat "$tmp_list"`
  IFS="$ifs_save"
  popd >/dev/null
  rm -r "$dir/packages/$name"
}

pk-install-package()
{
    declare name="$1"
    declare dir="$2"

    pk-extract2 "$name" "$dir" "$INSTALL_PATH"
    mkdir "$dir/packages/$name"
    cp -r "$INSTALL_PATH/$name"/{desc,*.tar.bz2} "$dir/packages/$name"
}
