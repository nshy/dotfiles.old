#!/bin/bash
# Usage: PROGRAM_NAME DIR [GLOB]
# Makes next conversion.
#   file0.x     -> file000.x
#   file1.x     -> file001.x
#   .....
#   file10.x    -> file010.x
#   .....
#   file100.x   -> file100.x
# Prefix 'file' is determined as largest common prefix among files in DIR
# Number field width is calculated automatically.
# Optional GLOB gives possibility to handle only some files in DIR
# GLOB should be quoted to pass trough shell

# TODO Thing of better command arguments hanling
# maybe
#
# padnum 'dir/*.jpg'
#   or
# pannum dir/*.jpg
#
# instead of
# padnum dir '*.jpg'

set -e

. functions
dir=$1
glob=$2
tmp=`mktemp`

trap 'rm "$tmp"' EXIT

if [[ -z $dir ]]; then
  print_help "$0"
  exit 1
fi

if [[ ! -d $dir ]]; then
  echo "Invalid directory path '$dir'"
  exit 1
fi

cd "$dir"
ls -1 $glob > "$tmp"
width=0
echo "$tmp"

# determine prefix
pref=`sed -r ':a;N;s/(.*).*\n\1.*/\1/;ba' "$tmp"`
pref_len=${#pref}
echo "Suffix is '$pref'"

# determine width
while read file
do
  [[ ${file:pref_len} =~ ^[[:digit:]]+ ]] || continue
  len=${#BASH_REMATCH}
  if [[ $len -gt $width ]]; then
    width=$len
  fi
done < "$tmp"
echo "Padding width is $width"

declare -i rn=0 
# should be enough length
zeros='0000000000000000000000'
# rename files
while read file
do
  [[ ${file:pref_len} =~ ^([[:digit:]]+)([^[:digit:]]*)$ ]] || continue
  num=${BASH_REMATCH[1]}
  suf=${BASH_REMATCH[2]}

  # mv if num width is less then
  pad=$(( $width - ${#num} ))
  if [[ $pad -gt 0 ]]; then
    file2="${pref}${zeros:0:pad}${num}${suf}"
    mv $file $file2
    rn=rn+1
  fi
done < "$tmp"

echo "Conversion finished successfully. $rn files renamed."
