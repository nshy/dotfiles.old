#!/bin/bash

# Source this script to add mark support to bash
# directory stack
#
# Commands:
# a)heritage
#   pushd, popd commands have basically default functionality
#
#   popd - don't handle any additional flags
#   pushd DIR, pushd [+-]n are accepted
#
# b)additional
#   mark_mark LETTER marks top of directory stack
#
#   mark_go LETTER|NUMBER rotates stack so
#     that the directory with mark LETTER or the directory with NUMBER index
#     in stack become the top of the stack
#
#   mark_ls displays directory stack, the output looks very like the output
#     of dirs -v with marks added
#
#   these three commands have too long names to be utterly useful as
#     i wanted to keep global namespace clean and to avoid clashes. I personally
#     use next aliases in my .bashrc
#
#       alias go="mark_go"
#       alias dirs="mark_ls"
#       alias mark="mark_mark"
#
# Example of usage:
#
# ~ >cd
# ~ >mark h; pushd code; go h; pushd 1; mark c; go h; go c;
#
# RATIONALE
#
# PURPOSE
#
# With marks I don't need to type dirs every time I want
# to go to different directory from the stack when there more than
# two. In latter case I can switch by 'cd -' or 'pushd'
#
# IMPLEMENTATION
# The implementation is not the shortest possible as it doesn't spawn
# processes on pushd, popd, go, dirs and mark. The tradeoff is to
# be consise and compact or to be fast. I prefer the latter - with
# slow implementation I feel like loosing interactivity of the shell -
# new 'go' command was quite slow in comparison with 'native'
# 'popd' and 'pushd'.
#
# OK. Now I think I'm wrong. I can use output of the dirs command to
# keep track of directory stack and I guess command substitution with
# dirs command doesn't actually spawn a process. So there is a way to
# write a better code to support marks))).
#
# DETAILS
#
# I keep 'mark_to_idx' - relation of marks to indexes of directories
# in current stack and change it appropriately on 'go', 'pushd', 'popd'.
#
# 'mark_dirs' holds current directory stack, as mark_dirs[0] is subjected
# to changes on 'cd' an the latter isn't hooked into, mark_dirs[0] is
# not always up-to-date and updated when neeeded.
#
# TESTS
# run 'marks test' to run tests. Yes, the implemetation is quite
# complicated so that I needed tests to finish this script.


[[ $1 == 'test' ]] && shopt -s expand_aliases

declare -A mark_to_idx
declare -a mark_dirs
declare mark_cur
declare mark_pwd_save

alias mark_pushd_save="\pushd"
alias mark_popd_save="\popd"

alias pushd="mark_pushd"
alias popd="mark_popd"

mark_pop()
{
  mark_cur_find
  if [[ -n $mark_cur ]]
  then
    unset "mark_to_idx[$mark_cur]"
  fi
  for mark in ${!mark_to_idx[*]}
  do
    local i=${mark_to_idx[$mark]}
    mark_to_idx[$mark]=$(( i-1 ))
  done
}

mark_pop_dirs()
{
  local s=${#mark_dirs[*]}

  for (( i=0 ; i<$(( s-1 )) ; i++ ))
  do
    mark_dirs[i]=${mark_dirs[$(( i+1 ))]}
  done
  unset "mark_dirs[$(( s-1 ))]"
}

mark_popd()
{
  mark_popd_save >/dev/null || return
  mark_pop
  mark_pop_dirs
}

mark_rotate_dirs()
{
  # update 0 entry as we do not follow cd command
  mark_dirs[0]=$mark_pwd_save

  local s=${#mark_dirs[*]}
  declare -a tmp

  # shift to tmp array
  for (( i=0 ; i<s; ++i ))
  do
    local is=$(( ( $i + $1 ) % $s ))
    tmp[$i]=${mark_dirs[$is]}
  done

  unset "mark_dirs[@]"

  # copy tmp to mark_dirs
  for (( i=0 ; i<s; ++i ))
  do
    mark_dirs[$i]=${tmp[$i]}
  done
}

mark_push()
{
  for mark in ${!mark_to_idx[*]}
  do
    local i=${mark_to_idx[$mark]}
    mark_to_idx[$mark]=$(( i+1 ))
  done
}

mark_push_dirs()
{
  mark_dirs[0]=$mark_pwd_save
  local s=${#mark_dirs[*]}

  for (( i=s ; i>0 ; --i ))
  do
    local ip=$(( i - 1 ))
    mark_dirs[$i]=${mark_dirs[$ip]}
  done
  mark_dirs[0]=$mark_pwd_save
}

mark_rotate()
{
  for mark in ${!mark_to_idx[*]}
  do
    local i=${mark_to_idx[$mark]}
    local s=${#mark_dirs[*]}
    mark_to_idx[$mark]=$(( (i - $1 + s) % s ))
  done
}

mark_cur_find()
{
  mark_cur=
  for mark in ${!mark_to_idx[*]}
  do
    if (( ${mark_to_idx[$mark]} == 0 ))
    then
      mark_cur=$mark
      break
    fi
  done
}

mark_swap()
{
  for mark in ${!mark_to_idx[*]}
  do
    [[ ${mark_to_idx[$mark]} == 0 ]] && { mark_to_idx[$mark]=1; continue; }
    [[ ${mark_to_idx[$mark]} == 1 ]] && { mark_to_idx[$mark]=0; continue; }
  done
}

mark_swap_dirs()
{
  mark_dirs[1]=$mark_pwd_save
}

mark_pushd()
{
  if (( ${#*} > 1 ))
  then
    printf "Option -n isn\'t supported\n"
    return
  fi

  mark_pwd_save=$PWD
  mark_pushd_save $1 > /dev/null || return

  # no arguments
  if (( ${#*} == 0 ))
  then
    mark_swap
    mark_swap_dirs
    return
  # +n argument
  elif [[ $1 =~ \+([[:digit:]]+) ]]
  then
    local s=${BASH_REMATCH[1]}
    mark_rotate $s
    mark_rotate_dirs $s
    return
  # -n argument
  elif [[ $1 =~ \-([[:digit:]]+) ]]
  then
    local s=$(( ${#mark_dirs[*]} - ${BASH_REMATCH[1]} - 1))
    mark_rotate $s
    mark_rotate_dirs $s
    return
  else
    # dir argument
    mark_push
    mark_push_dirs
  fi
}

mark_mark()
{
  if [[ ! $1 =~ ^[[:alpha:]]$ ]]
  then
    printf 'Mark name should be one [:alpha:] symbol\n'
    return
  fi

  if [[ ${!mark_to_idx[@]} =~ $1 ]]
  then
    printf 'Mark name "$1" is already in use\n'
    return
  fi

  mark_cur_find
  if [[ -n $mark_cur ]]
  then
    printf "Renaming position. Old name was '$mark_cur'\n"
    unset "mark_to_idx[$mark_cur]"
  fi

  mark_to_idx[$1]=0
}

mark_ls()
{
  declare -a mark_pos

  for mark in ${!mark_to_idx[*]}
  do
    mark_pos[${mark_to_idx[$mark]}]=$mark
  done

  mark_dirs[0]=$PWD
  # escape / in pwd
  local home=${HOME//\//\\/}
  for (( i=0; i<${#mark_dirs[*]} ; ++i ))
  do
    local d=${mark_dirs[i]}
    printf ' % -2s %s %s\n' "$i" "${mark_pos[$i]:- }" "${d/#$home/~}"
  done
}

mark_go()
{
  # go by number (convert to pushd +n)
  if [[ $1 =~ [[:digit:]]+ ]]
  then
    mark_pushd "+$1"
    return
  fi

  local l=${mark_to_idx[$1]}
  if [[ -z $l ]]
  then
    printf 'No such mark name\n'
    return
  fi

  mark_pushd "+$l"
}

#######################################################################
#
#  TEST PART

# we are sourced
[[ $1 != 'test' && $0 != $BASH_SOURCE ]] && return
# we are executed
[[ $1 != 'test' && $0 == $BASH_SOURCE ]] && exit

dir=$(mktemp -d)
trap 'rm -r "$dir"' EXIT

cd "$dir"
mkdir builds
mkdir code

tear_down()
{
  if [[ -n $mark_cur ]]
  then
    unset "mark_to_idx[$mark_cur]"
  fi
}

assert_equal()
{
  if [ "$1" != "$2" ]
  then
    echo 'Assertion "strings are equal" failed'
    echo '---1---'
    echo "$1"
    echo '---2---'
    echo "$2"
    result="FAIL"
    color='\e[31m'
  else
    result="OK"
    color='\e[32m'
  fi
}

assert_ls()
{
  assert_equal "$(mark_ls)" "${1//\~/$dir}"
}

echo_suit()
{
  echo -e "------------\e[33m$1\e[m"
}

echo_res()
{
  printf "%-40s$color[$result]\e[m\n" "$1"
}

main_test()
{
  echo_suit "Main test"
  cd "$dir"
  # ~

  assert_ls $' 0    ~'
  echo_res 'Init mark_ls test'

  pushd code
  # ~/code ~

  assert_ls $' 0    ~/code\n 1    ~'
  echo_res 'Pushd dir test'

  pushd

  assert_ls $' 0    ~\n 1    ~/code'
  echo_res 'Pushd test'

  pushd builds
  # builds ~ code
  pushd +2
  # code builds ~

  assert_ls $' 0    ~/code\n 1    ~/builds\n 2    ~'
  echo_res 'Pushd +2 test'

  pushd +1
  # builds ~ code

  assert_ls $' 0    ~/builds\n 1    ~\n 2    ~/code'
  echo_res 'Pushd +1 test'

  pushd -0
  # code builds ~

  assert_ls $' 0    ~/code\n 1    ~/builds\n 2    ~'
  echo_res 'Pushd -0 test'

  pushd -1
  # builds ~ code

  assert_ls $' 0    ~/builds\n 1    ~\n 2    ~/code'
  echo_res 'Pushd -1 test'

  mark_mark b

  assert_ls $' 0  b ~/builds\n 1    ~\n 2    ~/code'
  echo_res 'Mark test'

  pushd
  # ~ builds code

  assert_ls $' 0    ~\n 1  b ~/builds\n 2    ~/code'
  echo_res 'Mark after pushd test'

  pushd
  # builds ~ code
  pushd +1
  # ~ code builds

  assert_ls $' 0    ~\n 1    ~/code\n 2  b ~/builds'
  echo_res 'Mark after pushd +1 test'

  pushd -0
  # builds ~ code

  assert_ls $' 0  b ~/builds\n 1    ~\n 2    ~/code'
  echo_res 'Mark after pushd -0 test'

  pushd
  # ~ builds code
  mark_mark h
  mark_go b
  # builds code ~

  assert_ls $' 0  b ~/builds\n 1    ~/code\n 2  h ~'
  echo_res 'After mark_go b test'

  mark_go 2
  # ~ builds code
  assert_ls $' 0  h ~\n 1  b ~/builds\n 2    ~/code'
  echo_res 'After mark_go 2 test'

  mark_mark 2 >/dev/null

  assert_ls $' 0  h ~\n 1  b ~/builds\n 2    ~/code'
  echo_res 'Bad mark test'

  mark_mark x >/dev/null

  assert_ls $' 0  x ~\n 1  b ~/builds\n 2    ~/code'
  echo_res 'Mark rename test'

  popd
  # builds code
  assert_ls $' 0  b ~/builds\n 1    ~/code'
  echo_res 'Popd test'

  # tear down
  popd
  tear_down
}

fix1_test()
{
  echo_suit 'Fix1 test'
  cd "$dir"
  mark_mark h
  pushd code

  assert_ls $' 0    ~/code\n 1  h ~'
  echo_res 'Test'

  popd
}

main_test
fix1_test
